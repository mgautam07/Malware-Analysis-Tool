from tkinter import *
from tkinter import filedialog
from extractor import predict_file
from temp import resultWindow
import ttkbootstrap as tb
import pefile
import os
import hashlib
import yara 
import sys
import requests
import time
import datetime

def resource_path(relative_path):
    try:
        base_path = sys._MEIPASS2
    except Exception:
        base_path = os.path.abspath(".")

    return os.path.join(base_path, relative_path)


root = tb.Window(themename="cosmo")
root.title("Malware Analysis Tool")
img = PhotoImage(file=resource_path('assets\\images\\finger.png'))
logoImg = PhotoImage(file=resource_path('assets\\images\\logo.png'))
root.iconphoto(False, logoImg)
# Set the size of the window
root.geometry("800x600")

def extract_author_name(file_path):
    try:
        pe = pefile.PE(file_path)
        if hasattr(pe, 'VS_FIXEDFILEINFO') and pe.FileInfo:
            for file_info in pe.FileInfo:
                if file_info.StringTable:
                    for string_table in file_info.StringTable:
                        for entry in string_table.entries:
                            if 'Author' in entry.key:
                                return entry.value.decode('utf-8', errors='ignore')
    except Exception as e:
        print(f"Error extracting author name: {e}")

    return "No author found"

# Function to analyze the selected file
def analyze_file(file_path):
    # Get file information
    file_size = os.path.getsize(file_path)
    file_hash = hashlib.md5(open(file_path, 'rb').read()).hexdigest()
    file_type = file_path.split('.')[-1]
    author = extract_author_name(file_path)
    prediction = 2
    if file_type == 'exe':
        prediction = predict_file(file_path)
    
    
    # Display the file information
    author_label.config(text="Author: " + author, fg="blue")
    hash_label.config(text="Hash: " + file_hash, fg="blue")
    type_label.config(text="Type: " + file_type, fg="blue")
    size_label.config(text="Size: " + str(int(file_size/1024)) + " kb", fg="blue")
    prediction_label.config(text="Prediction: " + ['Malicious', 'Legitimate', 'Invalid file type'][prediction], fg="blue")

# Function for yara rule matching of the selected file
def yara_analyze_file(file_path):
    rules = yara.load(resource_path('assets\\rules\\new_compiled_rules.yar'))
    matches = rules.match(file_path)
    if matches:
        yara_label.config(text="Yara: " + str(matches[0]), fg="red")
        return 1
    else:
        yara_label.config(text="Yara: No match found", fg="green")
        return 0

# Function for dynamic analysis the selected file
def dynamic_analysis(file_path):
    HEADERS = {"Authorization": "Bearer qccG1V_LYQESKT0Zrz7M0A"}

    with open(file_path, "rb") as sample:
        files = {"file": ("temp_file_name", sample)}
        r = requests.post("http://192.168.220.138:8080/tasks/create/file", headers=HEADERS, files=files)

    task_id = r.json()["task_id"]
    print(task_id)

    while True:
        r = requests.get(f'http://192.168.220.138:8080/tasks/view/{task_id}', headers=HEADERS)
        if r.json()["task"]["status"] != "reported":
            time.sleep(10)
        else:
            break
    
    r = requests.get(f'http://192.168.220.138:8080/tasks/report/{task_id}', headers=HEADERS)
    data = r.json()
    return {
        'duration': data['info']['duration'],
        'score': data['info']['score'],
        'target': data['target']['file']['name']
    }
    
# Function to select a file for analysis
def select_file():
    file_path = filedialog.askopenfilename()
    if file_path:
        file_label.config(text="Selected file: " + file_path)

        if file_path.split('.')[-1] == 'cpp':
            # with tempfile.TemporaryDirectory() as temp_dir:
            #     print(f'Temporary directory created at: {temp_dir}')
            compile_command = f'g++ -march=native -o compiled.exe {file_path}'
            os.system(compile_command)
            print(compile_command)
            analyze_file(resource_path('compiled.exe'))
            yara_analyze_file(resource_path('compiled.exe'))
        elif file_path.split('.')[-1] == 'exe':
            # Call the analyze_file function with the selected file path
            analyze_file(file_path)
            yres = yara_analyze_file(file_path)
            if yres == 1:
                yres = 'Malicious'
            else: 
                yres = 'Legitimate'
            dynamic_result = dynamic_analysis(file_path)

            pe = pefile.PE(file_path)
            if pe.OPTIONAL_HEADER.Subsystem == 2:
                ss = 'GUI'
            elif pe.OPTIONAL_HEADER.Subsystem == 3:
                ss = 'CUI'
            elif pe.OPTIONAL_HEADER.Subsystem == 5:
                ss = 'DLL'
            elif pe.OPTIONAL_HEADER.Subsystem == 7:
                ss = 'Driver'
            else:
                ss = 'Unknown'

            if pe.FILE_HEADER.Machine == 0x014C:
                machine_type = 'Intel 386 or later processors and compatible processors'
            if pe.FILE_HEADER.Machine == 0x0200:
                machine_type = 'Intel Itanium processor family'
            if pe.FILE_HEADER.Machine == 0x8664:
                machine_type = 'x64 (AMD64 or EM64T) architecture'
            if pe.FILE_HEADER.Machine == 0x01C0:
                machine_type = 'ARM little endian'
            if pe.FILE_HEADER.Machine == 0xAA64:
                machine_type = 'ARM64 little endian'

            res = [
                ['Score', dynamic_result['score']],
                ['Duration', dynamic_result['duration']],
                ['Target', dynamic_result['target']],
                ['Machine', machine_type],
                ['Number of Sections', pe.FILE_HEADER.NumberOfSections],
                ['Timestamp', datetime.datetime.utcfromtimestamp(pe.FILE_HEADER.TimeDateStamp).strftime('%Y-%m-%d %H:%M:%S UTC')],
                ['Entry Point', hex(pe.OPTIONAL_HEADER.AddressOfEntryPoint)],
                ['Target OS Version', f"Windows {pe.OPTIONAL_HEADER.MajorOperatingSystemVersion}.{pe.OPTIONAL_HEADER.MinorOperatingSystemVersion}"],
                ['Minimum OS Version', f"Windows {pe.OPTIONAL_HEADER.MajorSubsystemVersion}.{pe.OPTIONAL_HEADER.MinorSubsystemVersion}"],
                ['Software Version', f"{pe.OPTIONAL_HEADER.MajorImageVersion}.{pe.OPTIONAL_HEADER.MinorImageVersion}"],
                ['Linker Version', f"{pe.OPTIONAL_HEADER.MajorLinkerVersion}.{pe.OPTIONAL_HEADER.MinorLinkerVersion}"],
                ['Size of Headers', pe.OPTIONAL_HEADER.SizeOfHeaders],
                ['Size on Disk', os.path.getsize(file_path)],
                ['Size of Code', pe.OPTIONAL_HEADER.SizeOfCode],
                ['Subsystem', ss],
                ['dll', pe.OPTIONAL_HEADER.DllCharacteristics],
            ]
        else :
            dynamic_result = dynamic_analysis(file_path)
            yres = yara_analyze_file(file_path)
            if yres == 1:
                yres = 'Malicious'
            else: 
                yres = 'Legitimate'
            res = [
                ['Score', dynamic_result['score']],
                ['Duration', dynamic_result['duration']],
                ['Target', dynamic_result['target']],
                ['Yara result', yres]
            ]
        print(res)
        resultWindow(res)

# Create the UI elements
result_label = Label(root, text="MAT", font=('Times', 40))
result_label.pack(pady=(15,40))

logo = Label(root,image=img)
logo.pack(fill=X)

file_frame = Frame(root, padx=10, pady=10)
file_frame.pack(fill=X)


file_button = tb.Button(file_frame, text="Choose File", command=select_file, style='Outline.TButton')
file_button.pack(padx=(10,10),pady=(10,10))

file_label = Label(file_frame, text="No file selected")
file_label.pack(padx=10, pady=10)

result_frame = Frame(root, padx=10, pady=10)
result_frame.pack(fill=X)

result_label = Label(result_frame, text="Analysis result", font='a 16 bold')
result_label.pack(side=LEFT, padx=35)

info_frame = Frame(root, padx=10, pady=10)
info_frame.pack(fill=X)

author_label = Label(info_frame, text="Author: ", fg="red")
author_label.pack(side=TOP, anchor=W, padx=15)

hash_label = Label(info_frame, text="Hash: ", fg="red")
hash_label.pack(side=TOP, anchor=W, padx=15)

type_label = Label(info_frame, text="Type: ", fg="red")
type_label.pack(side=TOP, anchor=W, padx=15)

size_label = Label(info_frame, text="Size: ", fg="red")
size_label.pack(side=TOP, anchor=W, padx=15)

prediction_label = Label(info_frame, text="Prediction: ", font='a 12 bold')
prediction_label.pack()

yara_label = Label(info_frame, text="Yara: ", font='a 12 bold')
yara_label.pack()

root.mainloop()